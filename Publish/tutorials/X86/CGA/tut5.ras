program InputMe;
var  
    i, time,t: byte; 
    update,trigger: byte=0;
	ddx,delta : integer;
	src, dst : pointer;
	px, py,x,y,z : integer = 30;
		sine : incbin("data/sine.bin");

		cols : array[4] of byte=(cga_color1, cga_color1, cga_color2, cga_color3);
		
	perlin : incbin("data/perlin64.dat");
	const landscapeWidth : byte = 16;
	const landscapeLength : integer = 1024;
	landscape : array[landscapeLength] of byte;
	curPos : integer = 0;

/*

	TEST with movement
	W A S D   to move around. WORK IN PROGRESS

*/


@export "images/image2.flf" "images/image2.bin" 0
	data : incbin("images/image2.bin");



@spritecompiler "images/sprites.flf" "cat" 0 0 5 3

procedure DrawSprite(xx,yy : integer);
begin
	ddx:=(xx/2)&1;
	xx:=xx/4;
	yy:=yy*80;
	src:=toPointer(hi(data),lo(data)+xx+yy);
//	src:=toPointer($6800,xx+yy);
	dst:=toPointer($B800,xx+yy);
	asm("
		mov ax,[dst]
		mov es,ax
		mov di, [dst+2]
		
		mov ax,[src]
		mov ds,ax
		mov si, [src+2]
		");
	if (ddx=0) then
		asm(" call cat_sprite1");
	if (ddx=1) then
		asm(" call cat_sprite0");

end;


procedure InitLandscape();
begin
	xx:=0;
	for x:=0 to landscapeLength do 
	begin
		
		yy:=perlin[x];
		y:=perlin[xx]/4;
		y:=yy-y;
		y:=260-y;
		if (y>190) then y:=190;
		landscape[x]:=y;
		xx:=xx+4
	end;

end;

procedure RenderLandscape(rl_color:byte);
begin
	if (update=0) then
		return();
	x:=landscapeWidth- delta;
	xx := 320 / landscapeWidth;
	z:=curPos;
	xx:=xx;
	
	for i:=0 to landscapeWidth-1 do
	begin
		DrawLineCGA(^$B800, x, landscape[z], x+xx,landscape[z+1] , rl_color);
		x:=x+xx;
		z:=z+1;
	end;
	update:=update-1;

end;

procedure RenderTriggerLandscape();
begin
	RenderLandscape(cga_color0);
	if (trigger=1) then
	begin
		delta:=delta +8;
		if (delta=landscapeWidth) then
		begin
			curPos:=curPos+1;
			delta:=0;
		end;
	end;
	if (trigger=2) then
	begin
		if (delta=0) then
		begin
			curPos:=curPos-1;
			delta:=landscapeWidth;
		end;
		delta:=delta -8;
	end;
	trigger:=0;
	RenderLandscape(cga_color1);

end;


begin
	init_cga_scanlines();
	init_drawline_cga();
	setscreenmode(mode_cga_320x200);
	InitLandscape();	
//	fillw(screen_cga+^25*^10,$AA55,2000);
//	fillw(screen_cga+^25*^10+^$200,$55AA,2000);
	
	// Overwrite  data. for now!
	fillw(data,0,8000);
//	DrawLine(0,0,160,100, cga_color2);

	px:=90;
	py:=30;
	update:=2;
	while (true) do
	begin
//		for i:=0 to 10 do 
		
//			waitforverticalblank();
		waitforverticalblank();
//		setcgapalette($011);
//		setcgapalette($010);
		i:=KeyPressed();
		if (i=1) then 
		begin
			i:=ReadKey();	
			if (i=100) then px:=px+2;
			if (i=97) then px:=px-2;
			if (i=115) then py:=py+1;
			if (i=119) then py:=py-1;
	
		end;
		if (px>100) then
		begin
			px:=98;
			update:=2;
			trigger:=1;
		end;		
		if (px<80) then
		begin
			px:=82;
			update:=2;
			trigger:=2;
		end;		
		DrawSprite(px,py);
		RenderTriggerLandscape();	
//		setcgapalette($011);
/*		x:=sine[time]/8;
		y:=sine[time+64]/8;
		x:=x-16;
		y:=y-16;
		drawlinecga(^$B800, 160,100,160+x,100+y, cga_color0);
		time:=time+1;
		x:=sine[time]/8;
		y:=sine[time+64]/8;
		x:=x-16;
		y:=y-16;
		drawlinecga(^$B800, 160,100,160+x,100+y, cga_color1);
*/
//		drawLineCGA(^$B800, 100,80, 110,90, cga_color3);

	//		setcgapalette($010);
end;

end.
