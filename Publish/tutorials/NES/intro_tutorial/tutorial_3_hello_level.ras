program Tutorial_3_hello_level;

/*
	
	This example shows how to draw a simple background, turn on sprites,
    move the sprites around & finally play some music

*/

var  
   	i,k,j: byte; 
   	// Use the original zelda music score
	music: incnsf("music/zelda.nsf");
	// Standard palette. Use YYchr (https://www.romhacking.net/utilities/119/) to create and edit.


	// Location of the sprite
	sprite_x, sprite_y : byte;

	// Data location of the sprite (at $0200)
//	@define spriteLocHi $03
	@define spriteLoc $204
	
	palette: incbin("tiles/game_tiles.pal");
	
// Make sure game tiles are being automatically exported
@export "tiles/game_tiles.flf" "tiles/game_tiles.bin" 256


// Make sure that the sprites are automatically exported! 3 in total
@export "tiles/game_sprite_meta.flf" "tiles/spritedata.bin" 3
	spriteData : incbin("tiles/spritedata.bin");	
	// Format: Y, sprite, palette, X

// Export & include level data
@export "levels/game_levels.flf" "levels/game_levels.bin" 3
	levels : incbin("levels/game_levels.bin");	
	

// Export & include meta tiles
@export "tiles/game_meta_tiles.flf" "tiles/metatiles.bin" 3
	meta : incbin("tiles/metatiles.bin");	


@define levelpointer lp

	// Level data
   m_rl_width, m_rl_height : byte;
   m_rl_sizex, m_rl_sizey : byte;
   m_rl_startx, m_rl_starty : byte;
   m_rl_dataSize, m_rl_pos : byte;
   m_rl_i, m_rl_j, m_rl_val, m_rl_idx: byte;
   m_rl_chunksize, m_rl_chunks : byte;
   m_li, m_lj : byte;


	isRendering: byte;
	newFrame: byte;
	mc,zp, lp,dp,zp2:pointer;




procedure ReadHeader();

begin
	@levelpointer := levels;

	// Read level header info

	m_rl_sizex := @levelpointer[0];
	m_rl_sizey := @levelpointer[1];

	m_rl_width := @levelpointer[2];
	m_rl_height := @levelpointer[3];

	m_rl_startx := @levelpointer[4];
	m_rl_starty := @levelpointer[5];

	m_rl_chunks := @levelpointer[6];
	m_rl_chunksize := @levelpointer[7];

	m_rl_dataSize := @levelpointer[8];

end;



procedure RenderMetaBlock(zz : pointer);
begin
	
	zp:=zz;
	for i:=0 to 2 do
	begin	
		ppusingle(hi(zp),lo(zp), dp[0]);
		zp:=zp+1;
		ppusingle(hi(zp),lo(zp), dp[1]);
		zp:=zp+31;
		dp:=dp+2;
	end;

end;




procedure RenderLevel();
begin
	// Turn off NMI, or else everything will crash while rendering...
	ToggleNMI(0);
	ToggleSprites(0);
	ToggleBackground(0);
	isRendering:=true;
	togglevram32inc(false);
	
	
	newFrame:=0;
	// Go past header
	@levelpointer := levels;
	@levelpointer := @levelpointer +32;

	// Calculate position in level layout

	m_rl_pos := m_rl_sizex*m_lj + m_li;
	
	m_rl_val := m_rl_width*m_rl_height;
	i:=m_rl_val/4;

	@levelpointer := @levelpointer +m_rl_val*m_rl_pos;
	@levelpointer := @levelpointer +i*m_rl_pos;
	@levelpointer := @levelpointer +m_rl_dataSize*m_rl_pos;

	zp2:=$2000;
	for m_rl_j:=0 to m_rl_height do begin
		for m_rl_i:=0 to m_rl_width do begin
			i:=m_rl_i;	
			m_rl_val := lp[i];
			dp:=meta + m_rl_val*4;
	
			RenderMetaBlock(zp2);
			zp2:=zp2+2;
			
		 end;
		 zp2:=zp2+32;
		 mc:=mc+32;
		 @levelpointer:=@levelpointer+m_rl_width;
		 
	end;
	ppupoint($23,$C0);
	k:=0;
	for k:=0 to m_rl_val/4 do
		ppuWrite(lp[k]);
	
	@levelpointer:=@levelpointer+3 + m_rl_val/4;
	ppusingle($3F,00, $D); // Set background color

	ToggleNMI(1);
	isRendering:=false;

end;



// Forward decleration
procedure SetSpritePosition();

// Empty
interrupt IRQ();
begin

end;


// Moves the player. ReadInput populates the "buttons" variable
procedure MovePlayer();
begin
	ReadInput();
	sprite_x:=sprite_x+getbit(buttons,1)-getbit(buttons,0); // x axis
	sprite_y:=sprite_y-getbit(buttons,2)+getbit(buttons,3); // y axis
	// Set sprite location after update
	SetSpritePosition();	

	if (sprite_x>249) then 
	begin
		inc(m_li);
		sprite_x:= 16;
		RenderLevel();
		return();
	end;
	if (sprite_x<10) then 
	begin
		dec(m_li);
		sprite_x:= 248;
		RenderLevel();
		return();
	end;

end;


// NMI will automatically be called on every vblank. Update PPU gfx here! For now,
// it is emtpy. 


interrupt NMI();
begin
	// Startirq pushes a,x,y onto the stack
	Startirq(0);
	
	if (isRendering=true) then
	begin
		closeirq();
		asm("rti");
	end;



	// First, make sure that the PPU knows that sprites are located at @spriteLoc
	SetSpriteLocation(hi(^@spriteLoc));
	
	SetNametable(0);

	// Play the song!
	PlaySong();
	// MovePlayer should really be called outside the NMI, waste of raster time
	// Make sure that sprite properties are set, re-enable NMI
	ToggleSprites(1);
	ToggleBackground(1);

	ToggleSpriteSize(0);
	ToggleSpriteTableAddress(0);
	ToggleBackgroundTableAddress(1);


	MovePlayer();
	
	CloseIRQ();
end;




/*
	SetSpritePosition sets the sprite location (x,y) for the four sprites
	to (sprite_x, sprite_y)+(offset_x, offset_y), where the offsets are defined in colum 0,3 in 
 	the spritedata table. 
	
*/
procedure SetSpritePosition();
begin
	k:=0;
	j:=0;

	for i:=0 to 4 do begin
		poke(^@spriteLoc,k+0,spriteData[j+0]+sprite_y);
		poke(^@spriteLoc,k+3,spriteData[j+3]+sprite_x);
		k:=k+4;
		j:=j+4;
	end;

end;
/*
 	Simple sprite initialization: Copy sprite data, update sprite position
*/
procedure InitSprites();
begin
	fill(^$200,$FF,0);
	memcpy(spriteData, 0,^@spriteLoc,6*16);
	SetSpritePosition();
end;

/*
 	Renders an initial screen:
 		- attribute table filled with random value %10101010
		- background namespace(0) = $2000 filled with two rows of value 96 (some random block)
*/

/*
	Initializes variables
*/
procedure InitVariables();
begin
	sprite_x:=70;
	sprite_y:=40;
end;


// Starting point after resetting the NES
begin




	// Load palette
	LoadPalette(palette);
	// Set up background & color values
	
	ReadHeader();
	InitSprites();

	m_li:=0;
	m_lj:=0;
	// Turn on background
	ToggleBackground(1);
	// Display background in border 0
	ToggleBorderBackground(1);


	// Load music
	LoadSong(0);
	RenderLevel();
	InitVariables();
	// Turn on NMI and RUN!
	ToggleNMI(1);
	Loop();
end.
