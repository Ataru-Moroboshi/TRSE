program Twister;
var  

// Location of twister data
@define twister $3000
// Location of twister table position
@define ttablepos $9100

@define rasterMainPos 0

@requirefile "data/example10_screen.bin" "Please run the Fjong raytracer file 'example10_text_twister.fjo' before compiling this program"


	twist: incbin("data/example10_screen.bin",@twister);
	ttable: incbin("data/example10_table.bin",@ttablepos);
	loctab : array[128] of byte;
	charset: incbin("charsets/main.bin", $2000);
	
	ssy:byte=0;
	
	ll,y,i,j,time,ttime,k,l,tt, frame,h,shift,sh,a,b, scroll, sx,val : byte = 0;
	
	zp,zp2,p1,cp,tp,kp,cp2,tmpp:pointer;
	
	sine2 : array[256] of byte;

	keep : byte;

	text : cstring = ("TURBO RASCAL SYNTAX ERROR",0,0,0);


/*
	The following method calculates the lookup table position
	based on the current caracter (gi_c).
	Each table consists of 2 bytes for each row with a height of 16 rows using a total of 16 frames.
	In total, each character then takes up 2*16*16 =512 bytes. 
	Multiplication lookup with 512 is easy - just use your caharacter value (j) 
	as the high byte of the lookup table (=*256) and then multiply by two (=*512).  
*/
procedure getI(gi_c:byte);
begin
	// Place current character in "j"
	j:=tp[gi_c];
	if (j=$20) then begin // Account for space bar
		j:=1;
	end;
	i:=(j-1)*2; // since A is 1. Since this is used as the high byte, same as *512
	cp:=ToPointer(@ttablepos/$100+i,0);
end;

/*
	Updates the "loctab" used for twisting
*/
procedure UpdateTables();
begin
	getI(0);
	zp:=cp;
	getI(2);
	cp2:=cp;
	getI(1);

	val:=time/2;
	for i:=0 to 50 step 2 do begin
		j:=(shift*2+i);
		ll:=j/32;
		
		k:=val - sine2[i+tt]*1;
		k:=k/2;

			k:=k&15;
			if (tp[ll]=$20) then 
			begin 
				j:=0; 
//				k:=0; 
			end;

			tmpp:=zp;
			if (j>64) then begin 	
				tmpp:=cp2;
				j:=j-64;
			end; 
			if (j>32) then begin 	
				tmpp:=cp;
				j:=j-32;
			end; 
//			kp:=tmpp+32*38;
			kp:=tmpp;//+32*k;
			
			l:=kp[j];
			h:=kp[j+1];
		
		if (tp[ll]=$5A) then begin 
			l:=0;//lo(empty);
			h:=$50;//hi(empty);
		end;

//		loctab[i]:=l;
//		loctab[i+1]:=h;

/*		zp2:=zp2-1;
		zp2[0]:=$20;
		zp2[17]:=$20;
		zp2:=zp2+1;*/
		p1:=toPointer(h+$30, l);
		memcpyunroll(p1,0,zp2,16);
		zp2:=zp2+40;
				

	end;


end;



/*procedure UpdateTwister();
begin
	fill(^$8000,$20,16);

	j:=0;
	for y:=0 to 25 do begin

		l:=loctab[j];
		h:=loctab[j+1];
		
		p1:=twist;
		
		p1:=toPointer(hi(p1)+h, lo(p1)+l);
		// Fill start + end with $20
		zp2:=zp2-1;
		zp2[0]:=$20;
		zp2[17]:=$20;
		zp2:=zp2+1;
		memcpyunroll(p1,0,zp2,16);
		zp2:=zp2+40;
		j:=j+2;
	end;

end;
*/



interrupt RasterMain();
begin
	StartIRQ(0);


	//if (time&1=1) 
//	then
	 begin
			i:=(7-(sh));
			i:=i&7;
		//	waitnoraster(1);
			//ssy:=i;
			scrolly(i);
	end;

		scroll:=sine[tt+128]/2;
		sx:=scroll/8 + 6;
		scrollx(scroll&7);

	if (tp[6]=0) then tp:=text;

	
	hidebordery(1);



//		if (time&1=1) then begin
			zp2:=$0400;
			zp2:=zp2+sx;
			a:=0;
			b:=25;
//			UpdateTwister();
		if(time&1=1) then
			UpdateTables();
	
//		end
/*		else begin

		end;
*/
		frame:=(frame + 1)&31;

		
		inc(time);
		//if (time&1=1) then 
		inc(tt);
		inc(ttime);

		sh:=sh+1;
		if (sh=8) then begin
			shift:=shift+1;
			sh:=0;
			if (shift=16) then begin
				tp:=tp+1;
				shift:=0;
			if 
				tp[2]=0 then tp:=text;
		end;

		end;


	closeirq();
end;




begin
//	setbitmapmode();
	settextmode();	
	hidebordery(1);
	hideborderx(1);
	ssy := peek(^$3FFF,0);
	poke(^$3FFF,0,0);
	poke(^$D018, 0, $14);
//	setcharsetlocation($2000);
//	screenoff();
	SPRITE_BITMASK:=0;
	disableciainterrupts();
	setmemoryconfig(1,0,0);
	//fill(^$2000+^$21*^8,255,8);
	ClearScreen($20,^$0400);
	SCREEN_BG_COL:=RED;
	SCREEN_FG_COL:=RED;
	clearscreen(BLACK,^$D800);
	setcharsetlocation($2000);
	setmulticolormode();
	setbank(VIC_BANK0);
	
	tp:=text;
	for i:=0 to 0 do sine2[i]:=sine[i]/8;
	
	shift:=0;
	keep:=peek(^$01,0);
	sx:=10;
	RasterIRQ(RasterMain(),@rasterMainPos,0);
	EnableRasterIRQ();
	enableirq();
	Loop();
end.
