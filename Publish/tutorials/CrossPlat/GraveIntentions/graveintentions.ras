program GraveIntentions;
var  

@define roomID 239
@define cnl 240
@define ccol 241
@define cexit 242
@define ppos 238

@define c1 14
@define c2 1
@define c3 0
@define dir_N %00001000
@define dir_S %00000100
@define dir_E %00000010
@define dir_W %00000001

@define cursorChar $a0
@define clearChar $20


@define startx 1
@define starty 12
@define commandY 20

@define item_branch 1
@define animPos $4000

//@export "screens/room1.flf" "screens/room1.trm" 256





    i,j,k,time,key,prevKey: byte = 0;  
   	// Player start position
	player_x:byte = 16;
	player_y:byte = 16;   
	cx, cy, curCol,curExits,row,col,bgCol, fgCol, decrunchIndex: byte = 0;
	columntab : array[256] of byte;
	chartab : array[64] of byte = (
	$00,$51,$00,$20, $32,0,0,0,
	$6f,$51,$7d,$00, $72,0,0,0,
	$6c,$40,$7a,$6e, $00,0,0,0,
	$4E,$4F,$4b,$4D, $30,0,0,0,
	$56,$55,$48,$42, $00,0,0,0,
	$58,$54,$46,$43, $00,0,0,0,
	$00,$45,$53,$5a, $00,0,0,0,
	$00,$51,$00,$00, $00,0,0,0);

	commandNotOK : byte=true;
	roomP,zp : pointer;


	maxFrames, compressionType, hasTimeStamps, endChar, skipChar, curFrame : byte = 0;
	roomTest: incbin("screens/room1.trm",@animPos);
@include "packed_resources1.ras"

//@export "charset/charset.flf" "charset/charset.bin" 256   
/*@ifdef C64
@define charsetPos $2000
@endif
*/
//	charset:incbin("charset/charset.bin",@charsetPos);

@include "rooms.ras"

@ifdef C64
@include "c64_methods.ras"

@endif

@include "trm.ras"

procedure MainInput();
begin

end;


procedure FindRoom();
var
	notDone : byte = true;
begin
	roomP := room1;
	while (notDone) do
	begin
		if (roomP[0]=@roomID) do
		begin
			bgCol:=roomP[3];
			fgCol:=roomP[4];
			decrunchIndex:=roomP[5];
			if (roomP[1]=player_x and roomP[2]=player_y) then
				return();
			roomP:=roomP+5;
		end;

	end;
	roomP:=0;
end;

procedure NewLine(i:byte);
begin
	cx:=@startx;
	cy:=cy+i;
end;



procedure PrintLine(tp:pointer);
var 
   i:byte;
begin
	while (tp[0]<>0) do
	begin
		i:=tp[0];
		if (i>96 and i<123) then
		  i:=i-96;
		moveto(cx,cy,hi(screen_char_loc));
	 	screenmemory[0]:=i;
		moveto(cx,cy,hi(screen_col_loc));
	 	screenmemory[0]:=curCol;
		inc(cx);
		tp:=tp+1;
	end;
end;


procedure PrintRoomText();
var
	i,j,print : byte;
	zp:pointer;
begin
	zp:=roomP;
	zp:=zp+6;
	cx:=@startx;
	curCol:=@c1;
	cy:=@starty;
	clearscreen(key_space,screen_char_loc);
	NewLine(1);
	while (zp[0]<>0) do 
	begin
		print:=true;
		i:=zp[0];
		if (i=@cnl) then
		begin
			cx:=@startx;
			inc(cy);
			print:=false;
			zp:=zp+1;			
		end;
		if (i=@ccol) then
		begin
			curCol:=zp[1];
			zp:=zp+2;
			print:=false;			
		end;
		if (i=@cexit) then
		begin
			print:=false;
			curExits:=zp[1];
			zp:=zp+2;	
		end;
		if (print) then
		begin
			moveto(cx,cy,hi(screen_char_loc));
			if (i>96 and i<123) then
			  i:=i-96;
//			if (i>240 and i<250) then
//			  i:=i-240;
			  

			screenmemory[0]:=i;
			moveto(cx,cy,hi(screen_col_loc));
		 	screenmemory[0]:=curCol;
		 	
			inc(cx);
			zp:=zp+1;
		end;
	end;
	NewLine(1);
	curCol:=@c1;
	PrintLine("Exits ");
	curCol:=@c2;
	
	if (curExits & @dir_N=@dir_N) then
		PrintLine("North ");
	if (curExits & @dir_S=@dir_S) then
		PrintLine("South ");
	if (curExits & @dir_E=@dir_E) then
		PrintLine("East ");
	if (curExits & @dir_W=@dir_W) then
		PrintLine("West ");
		
end;	




procedure InitializeRoom();
begin
	FindRoom();
	decrunchfromindex(resources,decrunchIndex);
	ReadAnimationHeader();
	clearscreen(fgCol, screen_col_loc);	
	screen_fg_col:=bgCol;
/*	moveto(5,5,$04);
	printdecimal(maxFrames,2);
	moveto(5,6,$04);
	printdecimal(compressionType,2);
	moveto(5,7,$04);
	printdecimal(endChar,2);
	Loop();
*/
	PrintRoomText();
end;




procedure Init();
begin
	k:=$FF;
	fill(columntab,$ff,0);
	for i:=0 to 0 do 
	begin
		if (i=$ff-$80) then k:=$70;
		if (i=$ff-$40) then k:=$60;
		if (i=$ff-$20) then k:=$50;
		if (i=$ff-$10) then k:=$40;
		if (i=$ff-$08) then k:=$30;
		if (i=$ff-$04) then k:=$20;
		if (i=$ff-$02) then k:=$10;
		if (i=$ff-$01) then k:=$00;
		
		columntab[i]:=k;

	end;
	
	ClearScreen(key_space,screen_char_loc);
@ifdef C64	
	SetCharsetLocation($1800);
	screen_bg_col:=black;
@endif
end;

// Clear command stuff
procedure PrepareCommand();
var
	i:byte;
begin

	moveto(0,@commandY,hi(screen_char_loc));
	for i:=0 to screen_height-@commandY do
	begin
		fill(screenmemory,@clearChar,screen_width);
		screenmemory:=screenmemory+screen_width;
	end;
	moveto(@startx,@commandY,hi(screen_char_loc));
	cx:=@startx;
	cy:=@commandY;
end;

procedure WaitForCommand();
var
	isNotDone : byte=true;
	cur,reset,time: byte = 0;
begin
	isNotDone:=true;
	while (isNotDone) do
	begin
		waitforraster(0);
		waitforraster(255);
		asm("
		lda #$0
	sta $dc03	; port b ddr (input)
	lda #$ff
	sta $dc02	; port a ddr (output)
			
	lda #$00
	sta $dc00	; port a
	lda $dc01       ; port b
	cmp #$ff
	beq nokey
	; got column
	tay
			
	lda #$7f
	sta nokey2+1
	ldx #8
nokey2:
	lda #0
	sta $dc00	; port a
	
	sec
	ror nokey2+1
	dex
	bmi nokey
			
	lda $dc01       ; port b
	cmp #$ff
	beq nokey2
			
	; got row in X
	stx row
	txa
	lda columntab,y
	ror
	ror
	ror
	ror
	sta col			
	ora row
;	sec
	jmp cont
nokey:
	lda #0
cont:	
	sta key
	

		");
//			screenmemory[cur]:=1;
		if (prevKey<>0 and key<>0) then
			if (key<>prevKey) then reset:=0;
		
		prevKey:=key;
		
		if (key<>0 and reset=0) then
		begin
//			key:=columntab[key];
/*			moveto(5,18,$04);
			printdecimal(row,2);
			moveto(9,18,$04);
			printdecimal(col,2);*/
			key:=chartab[63-col-row*8];
			screenmemory[cur]:=key;
			reset:=12;
			inc(cur);
//			moveto(10,18,$04);
//			printdecimal(key,3);

		end;

		if (reset<>0) then dec(reset);
//		i:=keypressed();
//		if (i=0
		if (time=0) then
		begin
			RenderNextPackedFrameCompressionType2();
			time := 16;
		end;
		dec(time);

	end;
end;



procedure MainLoop();
begin
	while (true) do
	begin
		commandNotOK:=true;
		InitializeRoom();
		while (commandNotOK) do
		begin
			PrepareCommand();
			WaitForCommand();
//			ExecuteCommand();
		end;
	end;
end;


begin
	Init();
	
	MainLoop();
end.
