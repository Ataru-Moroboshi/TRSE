program GraveIntentions;
var  

@define roomID 239
@define cnl 240
@define ccol 241
@define cexit 242
@define ppos 238

@define c1 14
@define c2 1
@define c3 0
@define dir_N %00001000
@define dir_S %00000100
@define dir_E %00000010
@define dir_W %00000001

@define cursorChar $a0
@define clearChar $20


@define startx 1
@define starty 12
@define commandY 20

@define item_branch 1
@define animPos $4000

//@export "screens/room1.flf" "screens/room1.trm" 256





    i,j,k,time,key,prevKey: byte = 0;  
   	// Player start position
	player_x:byte = 16;
	player_y:byte = 16;   
	cx, cy, curCol,curExits,row,col,bgCol, fgCol, decrunchIndex,clearMessage: byte = 0;

	commandNotOK, redraw : byte=true;
	roomP,zp : pointer;
	command : array[41] of byte;
	sSplit : array[41] of byte;


	maxFrames, compressionType, hasTimeStamps, endChar, skipChar, curFrame : byte = 0;
	roomTest: incbin("screens/room1.trm",@animPos);
@include "packed_resources1.ras"

//@export "charset/charset.flf" "charset/charset.bin" 256   
/*@ifdef C64
@define charsetPos $2000
@endif
*/
//	charset:incbin("charset/charset.bin",@charsetPos);

@include "rooms.ras"

@ifdef C64
@include "c64_methods.ras"

@endif

@include "trm.ras"


procedure FindRoom();
var
	notDone : byte = true;
begin
	notDone:=true;
	roomP := room1;
//	inc(^$D020);
	while (notDone) do
	begin
		if (roomP[0]=@roomID) do
		begin
			bgCol:=roomP[3];
			fgCol:=roomP[4];
			decrunchIndex:=roomP[5];
			if (roomP[1]=player_x and roomP[2]=player_y) then
				return();
			roomP:=roomP+5;
		end;
		roomP:=roomP+1;
	end;
	roomP:=0;
end;

procedure NewLine(i:byte);
begin
	cx:=@startx;
	cy:=cy+i;
end;



procedure PrintLine(tp:pointer);
var 
   i:byte;
begin
	while (tp[0]<>0) do
	begin
		i:=tp[0];
		if (i>96 and i<123) then
		  i:=i-96;
		moveto(cx,cy,hi(screen_char_loc));
	 	screenmemory[0]:=i;
		moveto(cx,cy,hi(screen_col_loc));
	 	screenmemory[0]:=curCol;
		inc(cx);
		tp:=tp+1;
	end;
end;


procedure PrintRoomText();
var
	i,j,print : byte;
	zp:pointer;
begin
	zp:=roomP;
	zp:=zp+6;
	cx:=@startx;
	curCol:=@c1;
	cy:=@starty;
	clearscreen(key_space,screen_char_loc);
	NewLine(1);
	while (zp[0]<>0) do 
	begin
		print:=true;
		i:=zp[0];
		if (i=@cnl) then
		begin
			cx:=@startx;
			inc(cy);
			print:=false;
			zp:=zp+1;			
		end;
		if (i=@ccol) then
		begin
			curCol:=zp[1];
			zp:=zp+2;
			print:=false;			
		end;
		if (i=@cexit) then
		begin
			print:=false;
			curExits:=zp[1];
			zp:=zp+2;	
		end;
		if (print) then
		begin
			moveto(cx,cy,hi(screen_char_loc));
			if (i>96 and i<123) then
			  i:=i-96;
			  

			screenmemory[0]:=i;
			moveto(cx,cy,hi(screen_col_loc));
		 	screenmemory[0]:=curCol;
		 	
			inc(cx);
			zp:=zp+1;
		end;
	end;
	NewLine(1);
	curCol:=@c1;
	PrintLine("Exits ");
	curCol:=@c2;
	
	if (curExits & @dir_N=@dir_N) then
		PrintLine("N ");
	if (curExits & @dir_S=@dir_S) then
		PrintLine("S ");
	if (curExits & @dir_E=@dir_E) then
		PrintLine("E ");
	if (curExits & @dir_W=@dir_W) then
		PrintLine("W");
		
end;	




procedure InitializeRoom();
begin
	FindRoom();
	decrunchfromindex(resources,decrunchIndex);
	ReadAnimationHeader();
	clearscreen(fgCol, screen_col_loc);	
	screen_fg_col:=bgCol;
	PrintRoomText();
end;




procedure Init();
begin
	
	ClearScreen(key_space,screen_char_loc);
@ifdef C64	
	SetCharsetLocation($1800);
	screen_bg_col:=black;
@endif
end;

// Clear command stuff
procedure PrepareCommand();
var
	i:byte;
begin

	moveto(0,@commandY,hi(screen_char_loc));
	for i:=0 to screen_height-@commandY-clearMessage do
	begin
		fill(screenmemory,@clearChar,screen_width);
		screenmemory:=screenmemory+screen_width;
	end;
	clearMessage:=0;
	moveto(@startx,@commandY,hi(screen_char_loc));
	cx:=@startx;
	cy:=@commandY;
end;

procedure Message(p:pointer);
var 
	i:byte;
begin
	moveto(0,24,hi(screen_char_loc));
	i:=cy;
	cy:=24;
	PrintLine(p);
	cy:=i;
	clearMessage:=1;
end;


procedure ExecuteCommand();
var
	cmd, arg1 : pointer;
	cmdGo : string="go";
	cmdN : string="n";
	ok : byte=false;
begin
	ok:=false;
	if (command[0]=0) then return();
	StrToLower(command);
	strSplit(command, sSplit, key_space);
	// Command
	cmd:=strgetfromindex(sSplit,0);
	arg1:=strgetfromindex(sSplit,1);

	if (strcmp(cmd,cmdGo)) then
	begin
		if (strcmp(arg1,cmdN)) then
		begin
			player_y:=player_y-1;
			ok:=true;
			redraw:=true;
		end;
		
		if (ok=false) then
		begin
			Message("I don't know where to go");			
		end;
	end;
	commandNotOK:=1-ok;
end;



procedure WaitForCommand();
var
	isNotDone, renderChar : byte=true;
	cur,reset,time, curPos, firstKey, blink: byte = 0;
begin
	isNotDone:=true;
	while (isNotDone) do
	begin
		waitforraster(0);
			
		renderChar:=true;
		key:=getKey();
		if (key=$FF) then
			firstKey:=0;
		prevKey:=key;
		
		if (key<>$FF and reset=0) then
		begin
			if (firstKey=0) then
				reset:=16
			else
				reset:=8;
				
			firstKey:=1;

			if (key=$F7) then // backspace
			begin
				screenmemory[cur]:=key_space;
				if (cur<>0) then
					cur:=cur-1;
				screenmemory[cur]:=key_space;
			
				renderChar:=false;		
			end;
			if (key=$8E) then // return 
			begin
				renderChar:=false;
				memcpy(screenmemory,0,command,40);
				command[cur]:=0;
				cur:=0;
				ExecuteCommand();
				isNotDone:=false;							
			end;

			if (renderChar) then
			begin
				screenmemory[cur]:=key;
				inc(cur);
			end;

		end;
		inc(blink);
		if (blink=16) then screenmemory[cur]:=key_space+$80;
		if (blink=32) then begin screenmemory[cur]:=key_space; blink:=0; end;
		
		if (reset<>0) then dec(reset);
		if (time=0) then
		begin
			RenderNextPackedFrameCompressionType2(22,8,0);
			time := 16;
		end;
		dec(time);

	end;
end;



procedure MainLoop();
begin
	while (true) do
	begin
		commandNotOK:=true;
		InitializeRoom();
		while (commandNotOK) do
		begin
			PrepareCommand();
			WaitForCommand();
		end;
	end;
end;


begin
	Init();
	
	MainLoop();
end.
