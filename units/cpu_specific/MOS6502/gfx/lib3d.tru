unit Lib3d;
@use "math/signedmath"
@use "gfx/gfx"
@use "math/matrix"
var
	object3d = record
		// All pointers
		vertices : integer;
		vertices_rot : integer;
		faces : integer;
		points_old : integer;
		points_new : integer;
		color : integer;
		noVerts : byte;
		noFaces,curDraw : byte;
		rotmat:integer;
	end;
	const N:integer = 10;
	objects : array[N] of object3d;

	ppo,ppn,fp,cp : pointer;
	ip:pointer of integer;
	startPos,curPos : integer = $8000;
	
	
	i,j,k,f,v,i1,i2,cx,cy,cz,zz : byte;
	xx,yy,iz:integer;



procedure FlipPointPointers(i : global byte);
begin
	if (objects[i].curDraw=1) then 
	begin
		ppo:=objects[i].points_new; 
		ppn:=objects[i].points_old; 
	end
	else
	begin
		ppo:=objects[i].points_old; 
		ppn:=objects[i].points_new; 
	end;

	objects[i].curDraw:=(objects[i].curDraw+1)&1;

end;



procedure InitializeData(startPos: global integer);
begin
	curPos := startPos;
end;

procedure AllocateWireframe(i,f,v : global byte);
begin
	objects[i].vertices := curPos;
	curPos += v*3; // 3 bytes per vertex
	objects[i].vertices_rot := curPos;
	curPos += v*6; // 3 bytes per vertex
	objects[i].faces := curPos;
	curPos += f*2; // 2 bytes per frame
	objects[i].points_old := curPos;
	curPos += v*2; // 2 bytes per point
	objects[i].points_new := curPos;
	curPos += v*2; // 2 bytes per point
	objects[i].color := curPos;
	curPos += v; // 2 bytes per point
	objects[i].rotmat := curPos;
	curPos += 4*4*2; // 32 bytes per matrix
	objects[i].noVerts := v;
	objects[i].noFaces := f;
end;



procedure RenderWireframe(i:global byte);
begin
	fp := objects[i].faces;
	cp := objects[i].color;
	k:=0;

	for j:=0 to objects[i].noFaces do
	begin
		i1 := fp[k];
		i2 := fp[k+1];
		k+=2;
		
		Gfx::Line(ppo[i1],ppo[i1+1],ppo[i2],ppo[i2+1],0);		
		Gfx::Line(ppn[i1],ppn[i1+1],ppn[i2],ppn[i2+1],cp[j]);		
	end;
	

end;


procedure FillColors(i,f:global byte);
begin
	fp := objects[i].color;
	fill(fp,f,objects[i].noFaces);
end;

procedure LoadObject(i:global byte; fp: global pointer);
begin
	v:=fp[0];
	f:=fp[1];
	objects[i].noVerts := v;
	objects[i].noFaces := f;
	fp+=2;
	
	objects[i].vertices := fp;
	fp:=fp + v*3;
	objects[i].faces := fp;

	objects[i].vertices_rot := curPos;
	curPos += v*6; // rotated are integer
	
	objects[i].points_old := curPos;
	curPos += v*2; // 2 bytes per point
	objects[i].points_new := curPos;
	curPos += v*2; // 2 bytes per point
	objects[i].color := curPos;
	curPos += f; // 2 bytes per point
	objects[i].rotmat := curPos;
	curPos += 4*4*2; // 32 bytes per matrix
	

end;

procedure RotateVertices(i:global byte);
var
	mat : integer;
begin

	fp := objects[i].vertices;
	ip := objects[i].vertices_rot;
	mat := objects[i].rotmat;
		
	for j:=0 to objects[i].noVerts do
	begin
		Matrix::MatMulVec3(mat, fp, ip);
		fp:=fp+3;
		ip:=ip+6;
	end;

end;


procedure ProjectSimple(i,cx,cy,cz: global integer);
begin
	ip := objects[i].vertices_rot;
	cp := ppn;
	
	for j:=0 to objects[i].noVerts do
	begin



		iz:=SignedMath::Divs16x8(ip[0],127);
		zz:=SignedMath::Divs16x8(zz,4);
		zz :=zz+cz;
		xx:=SignedMath::Divs16x8(ip[1],zz);
		yy:=SignedMath::Divs16x8(ip[2],zz);
			
		cp[0] := lo(xx)+cx;		
		cp[1] := lo(yy)+cy;


/*		i1:=fp[0]+fp[2];
		i2:=fp[1];
		cp[0] := i1+cx;		
		cp[1] := i2+cy;
*/		
		cp+=2;
		ip+=6;		
	end;


end;


end.