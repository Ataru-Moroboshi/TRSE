unit TrtPlayerb;

var
	ptrOrder, ptrPattern, zp : pointer;
	noChannels, noRows,i,j,note,noRowsMod : byte;
	curOrder, noOrder, curRow, speed, counter : byte;

	notes : array[] of byte = (
		255,    191,    223,
 	    134,    195,    225,
        141,    198,    226,
    		147,    201,    228,
    		153,    204,    230,
    		159,    207,    231,
    		164,    210,    232,
    		170,    212,    234,
    		174,    215,    235,
    		179,    217,    236,
    		183,    219,    237,
    		187,    221,    238,
    		191,    223,    239);
	

procedure Initialize( zp : global pointer );
begin
	noChannels := zp[0];	// how many channels
	noRows := zp[1];		// how many rows
	noOrder := zp[2]*noChannels;	// number of orders

	// set volume
	i:=peek(^$900E,0);
	i:=i | (15);
	poke(^$900E,0,i);	
	
	zp:=zp+3;
	
	// Pointer to pattern start
//	ptrPattern := zp + toPointer(zp[0],zp[1]);

	zp:=zp+2;
	ptrPattern := zp + noOrder; // skip past the order array to the pattern data

	speed := 8;
	counter :=0;
	ptrOrder := zp;  // current order pointer
	curOrder := 0; // order number
	curRow := 0; // row within pattern

//	curOrder := 0; 
end;


procedure Play();
begin
	counter:=counter+1;
	if (counter<speed) then
		return;
	counter := 0;
	
	for i:=0 to noChannels do
	begin
		// Get current order
		j := ptrOrder[curOrder+i];
		// Point to correct pattern
		noRowsMod := j << 4;
		zp := ptrPattern + noRowsMod; //j*noRows;	
		// get note:
		j := zp[curRow];
		poke(^$900a,i,j); // Play note!
		/*if (j&$80 <>0) then
		begin
			j:= j &$7F; // Semitone
			octave := j/12;
			if (octave<3) then
			begin
				if (j<>$7f) then
				begin
					// We have a note!
					note := mod(j,12);
					j := notes[3*note + octave];
					poke(^$900a,i,j); // Play note!				
				end;		
			end
			else poke(^$900a,i,0);
			
		end;
		*/				
	end;
	curRow:=curRow+1;
	if (curRow=noRows) then
	begin
		curRow:=0;
		curOrder:=curOrder + noChannels;
		if (curOrder=noOrder) then
		begin
			curOrder:=0;//Reset to start of song
		end;
	end;	

end;


end.
