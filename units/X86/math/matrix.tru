unit Matrix;
@use "system/tables"
@use "math/vector"
var

	type mat3 = array[16] of integer;
	type mat2 = array[4] of integer;
	type matp = pointer of integer;

	temp : mat3;
	vtmp : Vector::vec4;	
	@donotremove angle
	i,j,k,v,angle,v0,v1,v2,a0 : integer;
	c, s : integer;
	m,a:matp;
	

procedure MatMul3( a,b : matp );
begin
	for j:=0 to 4 do
	begin
		k:=0;
		for i:=0 to 4 do
		begin
			v:=a[k+0] * b[0+j];
			v+=a[k+1] * b[4+j];
			v+=a[k+2] * b[8+j];
			temp[k+j] := v/256;
             k:=k+4;
        end;
    end;

	memcpy32(#temp,a,6);
			
end;
procedure Print(m:global matp);
begin
	k:=0;
	for j:=0 to 4 do 
	begin
		for i:=0 to 4 do 
		begin
			Screen::PrintInt(m[k]);
			Screen::PrintChar(32);
			k:=k+1;
		end;
		Screen::PrintChar(10);
		Screen::PrintChar(13);
	end;

end;

procedure PrintVec(m:global matp);
begin
	k:=0;
	for i:=0 to 3 do 
	begin
		Screen::PrintInt(m[k]);
		Screen::PrintChar(32);
		k:=k+1;
	end;
	Screen::PrintChar(10);
	Screen::PrintChar(13);
	
end;



procedure MatMulVec3( a : global matp; vec, res: Vector::vecp );
begin
	v0:=vec[0];
	v1:=vec[1];
	v2:=vec[2];
	

	k:=0;
//	Print(a);
//	PrintVec(vec);
	for i:=0 to 3 do
	begin
//		asm(";here");
/*		v:=a[0]*v0;
		v+=a[1]*v1;
		v+=a[2]*v2;
*/
		asm("
			les di,[Matrix_a]
			mov ax,[Matrix_v0]
			mov bx,[es:di+0]
			imul bx
			mov [Matrix_v],ax
			
			mov ax,[Matrix_v1]
			mov bx,[es:di+2]
			imul bx
			add [Matrix_v],ax
			
			mov ax,[Matrix_v2]
			mov bx,[es:di+4]
			imul bx
			add [Matrix_v],ax

			");
		
//		v:=v/128;
/*	asm("
	mov ax,[Matrix_v]
	mov bx,256
	xor dx,dx
	cwd
	
	idiv bx
	mov [Matrix_v],ax


	");*/
		res[i] := v;
		a+=(4*2);
     end;
/*	PrintVec(res);
     while (true) do
     begin
     
	end;
*/
end;

procedure Normalize3(a : global matp);
begin
	asm("
		mov cx,12
		les di,[Matrix_a]
norm:
		mov ax,[es:di]
		xchg al,ah
		mov ah,0
		stosw
		loop norm			
	");
end;


procedure Identity(m:global matp);
begin
	k:=0;
	for i:=0 to 16 do m[i]:=0;
	m[0]:=256;
	m[5]:=256;
	m[10]:=256;
	m[15]:=256;
	
end;

/*
procedure mattranslate(var mm:matrix;x,y,z:double);
begin
	mm[0][0] := 1; mm[0][1] := 0; mm[0][2] := 0; mm[0][3] := 0;
	mm[1][0] := 0; mm[1][1] := 1; mm[1][2] := 0; mm[1][3] := 0;
	mm[2][0] := 0; mm[2][1] := 0; mm[2][2] := 1; mm[2][3] := 0;
	mm[3][0] := x; mm[3][1] := y; mm[3][2] := z; mm[3][3] := 1;
end;
*/


procedure RotateX(m:global matp; angle:global integer);
begin
	c := Tables::sine256[angle&255];
	s := Tables::sine256[(angle+64)&255];

	Identity(m);	
	m[5]:=c;
	m[6]:=0-s;
	m[9]:=s;
	m[10]:=c;
end;
/*

procedure matrotatey(var m:matrix;angle : double);
var
	c, s:double;
begin
	c := cos(angle);
	s := sin(angle);
	m[0][0] := c; m[0][1] := 0; m[0][2] := -s; m[0][3] := 0;
	m[1][0] := 0; m[1][1] := 1; m[1][2] := 0;  m[1][3] := 0;
	m[2][0] := s; m[2][1] := 0; m[2][2] := c;  m[2][3] := 0;
	m[3][0] := 0; m[3][1] := 0; m[3][2] := 0;  m[3][3] := 1;
end;

procedure matrotatez(var m:matrix;angle:double);
var
	c, s:double;
begin
	c := cos(angle);
	s := sin(angle);
	m[0][0] := c;  m[0][1] := s; m[0][2] := 0; m[0][3] := 0;
	m[1][0] := -s; m[1][1] := c; m[1][2] := 0; m[1][3] := 0;
	m[2][0] := 0;  m[2][1] := 0; m[2][2] := 1; m[2][3] := 0;
	m[3][0] := 0;  m[3][1] := 0; m[3][2] := 0; m[3][3] := 1;
end;
*/

end.
