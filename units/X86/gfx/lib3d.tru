unit Lib3d;
@use "math/matrix"
@use "system/memory"
@use "gfx/gfx"
var

	i,j,n,v,msize,size,xx,yy,zz,cx,cy,cz,k1,k2,k,k3,f1,f2,f3,f4:integer;
	mesh = record
	//	pos,rot: Vector::vec3;
		posx,posy,posz:integer;
		rotx,roty,rotz:integer;
		noVertices : integer;
		noFaces : integer;
		
		// vertices + rotated data
		vertices, vertices_rot : pointer of integer; 
		faces : pointer of integer;
		// 2D points
		points : pointer of integer;
	end;
	
	const MAX : integer = 10;

	rotMat : Matrix::mat3;
	objects : array[ MAX ] of mesh;
	v1,vr : Vector::vecp;
	p1,p2 : pointer of integer;	

procedure Allocate(i,v,n: global integer);
begin
	objects[i].posx:=0;
	objects[i].posy:=0;
	objects[i].posz:=0;
	objects[i].rotx:=0;
	objects[i].roty:=0;
	objects[i].rotz:=0;
	objects[i].noVertices:=v;
	objects[i].noFaces:=n;
	objects[i].vertices := Memory::GetMem(v*6);
	objects[i].faces := Memory::GetMem(v*6);
	objects[i].points := Memory::GetMem(v*4); // 2D
	objects[i].vertices_rot := Memory::GetMem(v*6);
	
//	objects[i].points := ptr($8000,0);
end;

procedure Box(i, size: global integer);
begin
	Allocate(i, 8,12);
	p1 := objects[i].vertices;
	msize := 0-size;
	p1[0] := size;	
	p1[1] := size;	
	p1[2] := size;	
	
	p1[3] := msize;	
	p1[4] := size;	
	p1[5] := size;	

	p1[6] := size;	
	p1[7] := msize;	
	p1[8] := size;	
	
	p1[9] := msize;	
	p1[10] := msize;	
	p1[11] := size;	

	p1[12] := size;	
	p1[13] := size;	
	p1[14] := msize;	
	
	p1[15] := msize;	
	p1[16] := size;	
	p1[17] := msize;	

	p1[18] := size;	
	p1[19] := msize;	
	p1[20] := msize;	
	
	p1[21] := msize;	
	p1[22] := msize;	
	p1[23] := msize;	
	
	p1:=objects[i].faces;
	p1[0]:=3*0;
	p1[1]:=2*2;
	p1[2]:=1*2;

	p1[3]:=3*2;
	p1[4]:=2*2;
	p1[5]:=1*2;


	p1[6]:=2*2;
	p1[7]:=1*2;
	p1[8]:=0*2;

	p1[9]:=2*2;
	p1[10]:=1*2;
	p1[11]:=0*2;




	p1[12]:=1*2;
	p1[13]:=5*2;
	p1[14]:=4*2;

	p1[15]:=5*2;
	p1[16]:=4*2;
	p1[17]:=0*2;



	p1[18]:=2*2;
	p1[19]:=6*2;
	p1[20]:=5*2;

	p1[21]:=6*2;
	p1[22]:=5*2;
	p1[23]:=1*2;


end;

procedure ProjectSimple(i,cx,cy,cz: global integer);
begin
	v1 := objects[i].vertices_rot;
	vr := objects[i].points;
	for j:=0 to objects[i].noVertices do
	begin
		zz:=v1[2];
		zz:=zz/256;
		zz+=cz;
//		if (zz=0) then zz+=1;

		xx:=v1[1];
		yy:=v1[0];
		asm(" xor dx,dx");		
		xx:=xx/zz;
		asm(" xor dx,dx");		
		yy:=yy/zz;
		vr[0] := xx+cx;		
		vr[1] := yy+cy;
		
		vr+=4;
		v1+=6;		
	end;
/*		asm(";here");
	vr := objects[i].points;
	for j:=0 to objects[i].noVertices do
	begin
		vr[0] := j*8;		
		vr[1] := (j*8);
		vr+=(2*2);
	end;*/



end;


procedure RenderPoints(i: global integer;p1:global pointer);
	
begin
	vr := objects[i].points;
	for j:=0 to objects[i].noVertices do
	begin
		xx := vr[0];
		yy := vr[1];
		Gfx::DrawLine(xx,yy,xx+8,yy+8, 0, p1);
		vr:=vr+4;
	end;
	
end;

procedure RenderLines(i,cx: global integer;p2:global pointer);
	
begin
	vr := objects[i].points;
	p1 := objects[i].faces;
	for j:=0 to objects[i].noFaces do
	begin
		k1:=p1[0];		
		k2:=p1[1];
		k3:=p1[2];
		Gfx::DrawLine(vr[k1],vr[k1+1],vr[k2],vr[k2+1], 0, p2);
		Gfx::DrawLine(vr[k2],vr[k2+1],vr[k3],vr[k3+1], 0, p2);
		Gfx::DrawLine(vr[k3],vr[k3+1],vr[k1],vr[k1+1], 0, p2);
		p1:=p1+6;
	end;
	
end;

procedure Rotate(i, xx,yy,zz : global integer);
begin
	Matrix::RotateX(rotMat,xx);
//	Matrix::Identity(rotMat);
//	for j:=0 to 16 do rotMat[j]:=0;
	v1 := objects[i].vertices;
	vr := objects[i].vertices_rot;
	
	for j:=0 to objects[i].noVertices do
	begin
		Matrix::MatMulVec3(rotMat,v1,vr);
		vr:=vr+6;
		v1:=v1+6;		
	end;
	// Done!

end;


end.
