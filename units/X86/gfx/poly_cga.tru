unit PolyCGA;
@use "system/screen"
@use "system/memory"
var
	p1,p2 : ^byte;	
	
code : array[556] of byte =( 
	$55,$fc,$30,$c9,$89,$ce,$30,$ed,$51,$38,$d8,$76,$01,$93,$38,$d0,
	$76,$01,$92,$38,$d3,$76,$02,$87,$d3,$89,$c5,$31,$ff,$30,$e4,$a8,
	$01,$74,$04,$81,$c7,$00,$20,$24,$fe,$d1,$e0,$d1,$e0,$d1,$e0,$01,
	$c7,$d1,$e0,$d1,$e0,$01,$c7,$89,$e8,$89,$d1,$28,$d9,$74,$3c,$fe,
	$c1,$28,$fd,$73,$1b,$f6,$dd,$bd,$29,$c5,$89,$2e,$24,$15,$bd,$88,
	$f5,$55,$bd,$38,$ee,$55,$bd,$fe,$c6,$55,$bd,$28,$e6,$55,$eb,$17,
	$bd,$01,$c5,$89,$2e,$24,$15,$bd,$88,$f1,$55,$bd,$38,$f1,$55,$bd,
	$fe,$ce,$55,$bd,$00,$e6,$55,$fe,$c5,$53,$51,$28,$c2,$fe,$c2,$28,
	$e6,$73,$20,$f6,$de,$bd,$28,$c2,$89,$2e,$3c,$14,$bd,$fe,$c2,$89,
	$2e,$50,$14,$bd,$38,$ea,$89,$2e,$52,$14,$bd,$88,$d5,$89,$2e,$56,
	$14,$eb,$1c,$bd,$00,$c2,$89,$2e,$3c,$14,$bd,$fe,$ca,$89,$2e,$50,
	$14,$bd,$38,$d1,$89,$2e,$52,$14,$bd,$88,$d1,$89,$2e,$56,$14,$fe,
	$c6,$88,$e5,$88,$e1,$89,$cd,$28,$c3,$fe,$c3,$28,$e7,$73,$20,$f6,
	$df,$b9,$28,$e6,$89,$0e,$3a,$14,$b9,$fe,$c6,$89,$0e,$44,$14,$b9,
	$38,$ee,$89,$0e,$46,$14,$b9,$88,$f5,$89,$0e,$4a,$14,$eb,$1c,$b9,
	$00,$e6,$89,$0e,$3a,$14,$b9,$fe,$ce,$89,$0e,$44,$14,$b9,$38,$f1,
	$89,$0e,$46,$14,$b9,$88,$f1,$89,$0e,$4a,$14,$fe,$c7,$88,$d9,$30,
	$ed,$09,$ce,$30,$c9,$31,$c0,$88,$e8,$00,$f8,$10,$e4,$f6,$f3,$88,
	$e5,$30,$e4,$86,$c1,$00,$f0,$10,$e4,$f6,$f2,$86,$cc,$51,$52,$57,
	$89,$ea,$89,$e9,$38,$cd,$72,$02,$86,$e9,$00,$e6,$00,$c2,$89,$d5,
	$08,$e4,$74,$08,$fe,$ce,$38,$f1,$77,$02,$88,$f1,$08,$c0,$74,$08,
	$fe,$ca,$38,$d0,$77,$02,$88,$d0,$28,$e9,$fe,$c1,$88,$e8,$30,$e4,
	$d0,$e8,$d0,$e8,$01,$c7,$b6,$ff,$80,$e5,$03,$f6,$dd,$80,$c5,$04,
	$38,$cd,$72,$1a,$d0,$e1,$d2,$ee,$88,$e9,$d0,$e1,$d2,$c6,$89,$f0,
	$26,$8a,$05,$20,$f0,$f6,$d6,$20,$f4,$08,$e0,$aa,$eb,$43,$28,$e9,
	$d0,$e5,$86,$e9,$d2,$e6,$86,$e9,$89,$f0,$26,$8a,$05,$20,$f0,$f6,
	$d6,$20,$f4,$08,$e0,$aa,$88,$ce,$d0,$e9,$d0,$e9,$74,$08,$89,$f0,
	$88,$e0,$30,$ed,$f3,$aa,$80,$e6,$03,$74,$16,$88,$f1,$b6,$ff,$d0,
	$e1,$d2,$ee,$89,$f0,$26,$8a,$05,$20,$f0,$f6,$d6,$20,$f4,$08,$e0,
	$aa,$5f,$5a,$59,$81,$c7,$00,$20,$81,$ff,$00,$40,$73,$0a,$4e,$f7,
	$c6,$ff,$00,$74,$11,$e9,$2d,$ff,$81,$ef,$b0,$3f,$4e,$f7,$c6,$ff,
	$00,$74,$03,$e9,$1f,$ff,$5b,$09,$db,$74,$2e,$58,$30,$c0,$95,$30,
	$e4,$09,$c5,$88,$d8,$09,$c6,$4e,$58,$a3,$3a,$14,$58,$a3,$44,$14,
	$58,$a3,$46,$14,$58,$a3,$4a,$14,$31,$c0,$88,$f8,$f6,$f3,$88,$e5,
	$88,$c4,$30,$c0,$01,$c5,$e9,$ec,$fe,$5d,$c3);
	
procedure Init();
begin
	p1:=#code;	
	p2:=ptr(0,$1300);
	asm("
		mov ax,ds
;		mov ax,
		mov [PolyCGA_p2+2],ax
	");
	memcpy8(p1,p2,556);
end;	

procedure Pre() inline;
begin
	asm("
		mov ax,$b800
		mov es,ax
	
	");
	
end;



procedure Draw(_ah, _al, _bh, _bl, _dh, _dl, _ch : byte) inline;
begin
	asm("
		call 0x1300
	
	");
end;	
	

var	

	maskOut : array[4] of byte = (%11000000,%11110000, %11111100, %11111111);
	@donotremove maskIn
	maskIn : array[4] of byte = (%11111111,%00111111, %00001111, %00000011);

	maskBit : array[4] of byte =( %00111111,  %11001111, %11110011,%11111100);
	@donotremove maskBitInv
	maskBitInv : array[4] of byte =(%11000000,   %00110000,%00001100,%00000011 );

	val : byte;
	dx1, dx2, ex1, ex2, i : integer;
	lx1, lx2, lx3, y ,xx1, xx2 : signed integer;
	dst,p,screen : pointer;
	v1,v2,j,d1,d2,d3,v3,v4,c1,v1x,v2x: byte;
	
	const shift : byte = 7;




procedure hline();
begin
//	dx1:=xx1>>8;
//	dx2:=xx2>>8;
	
	asm("
		mov cl,7
		mov ax,[PolyCGA_xx1]
		mov bx,[PolyCGA_xx2]
		sar  ax,cl
		sar  bx,cl
		
		cmp ax,bx
		jbe label0
		xchg ax,bx

label0:		
		
		mov word [PolyCGA_dx1],ax
		mov word [PolyCGA_dx2],bx


		
	");

asm("		
		push ax
		push bx
		
		
		and ax,3
		and bx,3
		mov cl,[ds:si+bx]
		mov [PolyCGA_v2],cl
		xor cl,255
		mov [PolyCGA_v2x],cl
;		mov si,PolyCGA_maskIn
		mov bx,ax
		mov dl,[ds:si+bx+4]
;		mov [PolyCGA_v1],cl
		mov dh,dl
		xor dh,255
;		mov [PolyCGA_v1x],cl
		pop bx
		pop ax
		mov cl,2
		sar ax,cl
		sar bx,cl

;		mov [PolyCGA_ex1],ax		
;		mov [PolyCGA_ex2],bx		
		
		les di,[PolyCGA_dst]
		add di,ax
		sub bx,ax

		cmp bx,0
		jne fullrun		
	
	");

//	v1:=maskIn[dx1&3];
//	v2:=maskOut[dx2&3];
/*
asm(";woot");
	if (dx1>dx2) then 
	begin
		Swap(dx2, dx1);
	end;
*/
//	ex1:=dx1>>2;
//	ex2:=dx2>>2;

	
	
//	if (ex1=ex2) then
	begin
		asm("
		mov bx,[PolyCGA_dx1]
		mov cx,[PolyCGA_dx2]		
		and cx,3
		and bx,3
		cmp cx,bx
		je alldone

		mov al,[es:di]
		push si
		mov si,PolyCGA_maskBit
		
lpp:
		and al,[si+bx] ; j:=j & maskBit[d1];
		mov ah, [PolyCGA_val]
		and ah, [si+bx+4] ; and with maskinv
		or al,ah		
		inc bx
		cmp cx, bx
		jne lpp		
		
		mov [es:di],al
		pop si
		
alldone:
		ret
		");				
		/*
		i:=ex1;
		ex1:=dx1&3;
		ex2:=dx2&3;
		
		if (ex1<>ex2) then
		begin
			
			j := dst[i];
			for d1:=ex1 to ex2 do
			begin
				j:=j & maskBit[d1]; // 00111111
				v2:=maskBitInv[d1]; // 11000000
				j:=j | (val&v2);
			end;
			dst[i] := j;
		end;
		*/	
	end;
//	else
	begin
		
//		v3 := v1 xor $FF;
//		v4 := v2 xor $FF;
/*		
		j:=dst[dx1];
		dst[dx1]:=(j&(v1 xor 255))|(val&v1);
		
		j:=dst[dx2];
		dst[dx2]:=(j&(v2 xor 255))|(val&v2);
*/

		asm("
fullrun:		
	
;			push bx		
			mov cl,[PolyCGA_val]
;			add di,[PolyCGA_ex1]
;			mov bx,[PolyCGA_ex1]
			mov al, byte [es:di]
			and al, dh; byte [PolyCGA_v1x]
			
			mov ah,cl
			and ah,dl ;[PolyCGA_v1]
			or al,ah
			mov byte [es:di],al

;			pop bx
;			mov bx,[PolyCGA_ex2]
;			sub bx,[PolyCGA_ex1]

			mov al, [PolyCGA_v2x]
			and al,byte [es:di+bx]
			mov ah,cl
			and ah,[PolyCGA_v2]
			or al,ah
			
			
			mov byte [es:di+bx],al
			mov al,cl
		
		");		
		
//		j:=dst[dx2];
//		dst[dx2]:=(j&(v2 xor 255))|(val&v2);
		asm("
;		les di,[PolyCGA_dst]
;		add di,[PolyCGA_ex1]
		add di,1
		
		mov cx, bx
		sub cx,1
;		sub cx,[PolyCGA_ex1]
		
;		mov al, [PolyCGA_val]
	 	rep stosb		
		");
		
/*		
		dx2:=dx2-dx1-1;
		if (dx2<40) then
		begin
			dx1+=1;
			p:=dst+dx1;
			fill(p,val, dx2);
		end;
*/		

	end;
end;




procedure Poly(x1,y1,x2,y2,x3,y3:signed integer;
                val : global byte);


begin
	if ( y1>y3 ) then
	begin
		Memory::Swap(x1,x3);
		Memory::Swap(y1,y3);

	end;
	
	
	if ( y2>y3 ) then
	begin
		Memory::Swap(x2,x3);
		Memory::Swap(y2,y3);

	end;
	if ( y1>y2 ) then
	begin
		Memory::Swap(x1,x2);
		Memory::Swap(y1,y2);

    end;
    	y1:=y1&$FFFE;
    	y2:=y2&$FFFE;
    	y3:=y3&$FFFE;


	if ( (y1-y3)=0 ) then y3+=2;
	if ( (y1-y2)=0 ) then y2+=2;
	if ( (y2-y3)=0 ) then y3+=2;

	lx1 := ((x1-x3))<<shift;
	lx2 := ((x1-x2))<<shift;
	lx3 := ((x2-x3))<<shift;
	
	
	lx1 := lx1/(y1-y3);
	lx2 := lx2/(y1-y2);
	lx3 := lx3/(y2-y3);
	
	
    xx1:=x1 << (shift);
	xx2:=xx1;
	y:=y1;
	dst := screen +y*40;//ptr($B800,y*40);
	lx1*=2;
	lx2*=2;
	lx3*=2;
	asm("
		mov si,PolyCGA_maskOut
	
	");
	while (y<y2) do
	begin
		hline();		      
		dst+=80;
        y+=2;
	
		xx1+=lx1;
		xx2+=lx2;


	end;
	lx2:=lx3;
	while (y<y3) do
	begin
		hline();		      
		dst+=80;
        y+=2;
	
		xx1+=lx1;
		xx2+=lx2;

	end;

end;

	
	
	
end.
