unit txt;
@use "system/screen"
var
	i:byte;
	CH:byte;
	temp_address_p: integer=0;
	
	Active_Page_Number:integer;
	
	ytab : array[25] of integer=(
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0,
		0,0,0,0,0,0);
	screen_memory: pointer;
	max_digits,next_digit: integer;
	temp_num_p: pointer;
	temp_num: integer;
	temp_i: byte=0;
	this_bbc: byte=0;
	in_str: pointer;
	CRLF: byte;
	
	o_cx:byte;
	o_cy:byte;
	
	// PC cursors		        
	const CUR_U: byte = $48;
	const CUR_D: byte = $50;
	const CUR_L: byte = $4B;
	const CUR_R: byte = $4D;


	/**
	
	Put a character at current cursor position
	
	**/
	procedure put_ch(CH:global byte);
	begin
		_AH:=$E;
		_AL:=CH;
	    _BH:=0;
	 
	    asm("
	    	int $10
	    ");
	end;

	/**
	
	Helper to set up screen pointers etc
	
	**/
	procedure DefineScreen();
    begin
	    Screen::SetMode($01);
    end;
    
    

    /**

	 Escape sequence
    
    **/
    procedure esc();
    begin
    	put_ch($1B);
	    put_ch($5B);
    end;


    
	/**

	Place the cursor at 0,0 top left of screen
	
	**/
	procedure cursor_home();
	begin
	    _AH:=$2;
	    _BH:=0;
	    _DH:=0;
	    _DL:=0;
	    asm("
	    	int $10
	    ");
	    
    end;

	/**
	
	Place the cursor at X, Y screen position
	
	**/
	procedure move_to(_text_x: byte, _text_y: byte);
    begin
	    _AH:=$2;
	    _BH:=0;
	    _DH:=_text_y;
	    _DL:=_text_x;
	    asm("
	    	int $10
	    ");
	    
    end;
	
	/**
	
	Wait for vertical blank (not yet implemented)
	
	**/
	procedure wait_vsync();
    begin
	    waitforverticalblank();
    end;

	/**
	
	Set the text colour (not available on all platforms)	
	
	**/
	procedure text_colour(_chosen_text_colour: byte);
    begin
	    
    end;	
	


	/**

	Get a character input from the keyboard	
	
	**/
	function get_key():byte;
    begin
	    _AH:=$0;
	 
	    asm("
	    
	    	int $16
	    	mov [txt_CH],AL
	    	
	    ");
	    // AL=ascii AH=scan code
	    
	    get_key:=CH;
    end;
    
    
	/**

	Get a character input from the keyboard	
	
	**/
	function get_scancode():byte;
    begin
	    _AH:=$0;
	 
	    asm("
	    
	    	int $16
	    	mov [txt_CH],AH
	    	
	    ");
	    // AL=ascii AH=scan code
	    
	    get_scancode:=CH;
    end;
    
        
    
	/**
	
	Wait for a key press	
	
	**/
	procedure wait_key();
    begin
	    get_key();
    end;
	/**

	Clear the keyboard buffer	
	
	**/
	procedure clear_buffer();
    begin
	    
    end;


	/**
    
    Get current cursor position to o_cx,o_cy
	
	**/
 	procedure get_cursor_position();
    begin
	    _AH:=$3;
	    _BH:=0;
	    asm("
	    	int $10
	    	mov [txt_o_cx],dl
	    	mov [txt_o_cy],dh
	    ");
	end;    

	/**
	
	Put a character at a X, Y screen coordinate
	
	**/
    procedure put_char_at(_atx,_aty,_atchar:byte);
    begin
	    
		get_cursor_position();	    
	    move_to(_atx,_aty);
	    put_ch(_atchar);
	    move_to(o_cx,o_cy);
	    
    end;

	/**

	Output a string at the current cursor location.
	Set Carriage Return on/off	
	
	**/
	procedure print_string(in_str: global pointer, CRLF: global byte);
	var
		
    begin
		Screen::Print(in_str);
	    
	    if(CRLF) then 
	    begin
		    put_ch(10);
		    put_ch(13);
	    end;
	    
    end;



	/**
	
	Return the character at chosen screen position
	
	**/
    function get_char_at(_col,_row:byte):byte;
    begin
	    get_cursor_position();
	    move_to(_col,_row);
	    
	    // Get the character at location
	    _AH:=$8;
	    _BH:=0;
	 
	    asm("
	    	int $10
	    	mov [txt_CH],AL
	    ");
	    
	    // restore cursor position
   	    move_to(o_cx,o_cy);
	    
	    // return the character
	    get_char_at:=CH;

    end;    

	/**
	
	Compare two strings for equality
	
	**/
	function str_compare(str1,str2:pointer):byte;


	procedure beep();
	begin
		
		put_ch(7);
		
		
	end;


	/**
	
	Output a string representation of a decimal number at current cursor position
	Set if you want carriage return true/false
	
	**/
	procedure print_dec(_in_n:byte, _add_cr:byte);
	begin
		
		Screen::PrintInt(_in_n);
	    if(CRLF) then 
	    begin
		    put_ch(10);
		    put_ch(13);
	    end;
	    
		
	end;

	/**
	
	Convert string to decimal number
	
	**/
	function str_to_dec(_in_str:pointer):byte;

	/**
	
	Get numeric input from keyboard
	
	**/
	function get_dec():integer;

	/**
	
	Get screen page
	
	**/    
    procedure get_page();
    begin
	    //BIOS Function Read Video mode
	    _AH:=$0f;
	    asm

				int $10
				mov 	[txt_Active_Page_Number],bh
	    end;

	    
    end;
    
	/**
	
	Hide flashing cursor
	
	**/
	procedure cursor_off();
	var

    begin
	    
		asm    	
				mov ah,$01
				mov ch,$20
				int $10 

		end;
	    
    end;

	/**
	
	Show flashing cursor
	
	**/
	procedure cursor_on();
	var

    begin
	    
		asm    	
				mov ah,$01
				mov ch,$06
				mov cl,$07
				int $10 

		end;
	    
    end;


	// Compare two strings for equality
	function str_compare(str1,str2:pointer):byte;
	var
		si:byte=0;
		_match:byte=False;
	begin
		si:=0;
		_match:=False;

		while(str1[si]>0 and str1[si]<>155) do
		begin
			if(str1[si]=str2[si]) then
			begin
				_match:=True;
			end
			else
			begin	
				_match:=False;
			end;

			si:=si+1;
		end;

		str_compare:=(_match);
	end;


	/**
	
	Output a string representation of a decimal number at chosen position
	
	**/
	procedure put_dec_at(_natx,_naty,_nat:byte);
	begin

		move_to(_natx,_naty);		
		Screen::PrintInt(_nat);
		
	end;
	
	
	function str_len(in_str: global pointer):byte;
	begin
		
		i:=0;
		
		// get the Str_Len by counting until char is 0
		while(in_str[i]<>0) do
		begin 
			i:=i+1;
		end;
		
		// Return
		str_len:=i;
		
	end;
	
	// print X spaces
	procedure print_space(max_digits: global integer);
	begin
		
		i:=0;
		for i:=0 to max_digits do
		begin
			put_ch(32);
		end;
		
	end;
	
	/**

	Output a string at the current cursor location but centered.
	Set Carriage Return on/off	
	Set the screen width
	Set reverse on/off
	
	**/
	procedure print_string_centered(in_str: global pointer, CRLF: global byte, _sc_w: byte);
	begin
		
		i:=0;
		max_digits:=0;
		
		// Get the length of the string
		i:=str_len(in_str);

		// padding should be half of width minus string length
		max_digits:=(_sc_w-i)/2;
			
		// Is it worth padding?
		if(max_digits>0 and i < 40) then
		begin	

			// Add the padding
			print_space(max_digits);
			
			// print the string
			print_string(in_str, CRLF);	

		end
		else
		begin
			// print the string
			print_string(in_str, CRLF);	
		end;
		

		
	end;
	
function get_string():integer;
   var
	_input_key, bp: byte;
	input_buffer: string=("                                                      ",0);
	p_input_buffer: pointer;
	   
   begin
   
	bp:=0;
 	_input_key:=0;
 	p_input_buffer:=#input_buffer;
 	
 	txt::cursor_on();
 	
	while (_input_key<>13) do
	begin

		_input_key:=txt::get_key();
		
		if(_input_key > 0 and _input_key < 255) then
		begin
			txt::put_ch(_input_key);
			p_input_buffer[bp]:=_input_key;
			bp:=bp+1;
		end;

		if(_input_key = 20) then
		begin
			txt::put_ch(32);			
			txt::put_ch(20);	
			bp:=bp-2;

		end;

		p_input_buffer[bp]:=0;
	end;
	
	txt::cursor_off();
	get_string:=(p_input_buffer);

   end;






	function str_to_dec(_in_str:pointer):byte;
	begin

		next_digit:=0;
		temp_num:=0;
		temp_i:=0;
		max_digits:=0;

		while(_in_str[max_digits]>0) do
		begin
			max_digits:=max_digits+1;
		end;
		max_digits-=1;

		for temp_i:=0 to max_digits do
		begin

			if(_in_str[temp_i]=48) then
			begin
				next_digit:=0;
			end
			else
			begin
				next_digit:=_in_str[temp_i]-48;
			end;

			temp_num:=(temp_num*10)+next_digit;
		end;

		str_to_dec:=(temp_num);
	end;	

	function get_dec():integer;
	begin
		temp_num_p:=get_string();
		get_dec:=(str_to_dec(temp_num_p));
	end;



   
	/**
	
	Clear screen and initialise pointers 
	Required for move_to etc
		
	**/
  	procedure cls();
    begin
		esc();
 		Screen::Print("2J");
	    DefineScreen();
    end;


end.